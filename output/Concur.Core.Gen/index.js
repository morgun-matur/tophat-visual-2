// Generated by purs version 0.14.2
"use strict";
var Concur_Core_Types = require("../Concur.Core.Types/index.js");
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad_Free = require("../Control.Monad.Free/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var GenStep = function (x) {
    return x;
};
var widgetYield = function (mx) {
    return function (w) {
        return Control_Bind.bind(Concur_Core_Types.widgetBind)(w)(function (a) {
            return Control_Applicative.pure(Concur_Core_Types.widgetApplicative)({
                "yield": mx,
                cont: a
            });
        });
    };
};
var yieldAndThen = function (x) {
    var $33 = widgetYield(new Data_Maybe.Just(x));
    return function ($34) {
        return Control_Monad_Free.wrap($33($34));
    };
};
var runWidget = (function () {
    var $35 = widgetYield(Data_Maybe.Nothing.value);
    return function ($36) {
        return Control_Monad_Free.liftF($35($36));
    };
})();
var pureYield = function (x) {
    return Control_Applicative.pure(Concur_Core_Types.widgetApplicative)({
        "yield": new Data_Maybe.Just(x),
        cont: Data_Unit.unit
    });
};
var $$yield = function ($37) {
    return Control_Monad_Free.liftF(pureYield($37));
};
var mapYieldGenWidget = function (f) {
    return Data_Functor.map(Concur_Core_Types.widgetFunctor)(function (r) {
        return {
            "yield": Data_Functor.map(Data_Maybe.functorMaybe)(f)(r["yield"]),
            cont: r.cont
        };
    });
};
var mapYield = function (f) {
    return Control_Monad_Free.hoistFree(function (v) {
        return mapYieldGenWidget(f)(v);
    });
};
var mapContGenWidget = function (f) {
    return Data_Functor.map(Concur_Core_Types.widgetFunctor)(function (r) {
        return {
            cont: f(r.cont),
            "yield": r["yield"]
        };
    });
};
var listToGen = (function () {
    var bthen = function (m1) {
        return function (m2) {
            return Control_Bind.bind(Control_Monad_Free.freeBind)(m1)(function (v) {
                return m2;
            });
        };
    };
    return Data_Array.foldr(function ($38) {
        return bthen($$yield($38));
    })(Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Data_Unit.unit));
})();
var functorGenStep = new Data_Functor.Functor(function (f) {
    return function (v) {
        return mapContGenWidget(f)(v);
    };
});
var genOrr = function (dictMonoid) {
    return function (wg) {
        var v = Control_Monad_Free.resume(functorGenStep)(wg);
        if (v instanceof Data_Either.Right) {
            return Control_Applicative.pure(Concur_Core_Types.widgetApplicative)(new Data_Either.Left(v.value0));
        };
        if (v instanceof Data_Either.Left) {
            return Control_Bind.bind(Concur_Core_Types.widgetBind)(v.value0)(function (r) {
                if (r["yield"] instanceof Data_Maybe.Nothing) {
                    return genOrr(dictMonoid)(r.cont);
                };
                if (r["yield"] instanceof Data_Maybe.Just) {
                    return Control_Alt.alt(Concur_Core_Types.widgetAlt(dictMonoid))(genOrr(dictMonoid)(r.cont))(Data_Functor.map(Concur_Core_Types.widgetFunctor)(Data_Either.Right.create)(r["yield"].value0));
                };
                throw new Error("Failed pattern match at Concur.Core.Gen (line 105, column 5 - line 107, column 48): " + [ r["yield"].constructor.name ]);
            });
        };
        throw new Error("Failed pattern match at Concur.Core.Gen (line 101, column 13 - line 107, column 48): " + [ v.constructor.name ]);
    };
};
var genToList = function (g) {
    var v = Control_Monad_Free.resume(functorGenStep)(g);
    if (v instanceof Data_Either.Right) {
        return Control_Applicative.pure(Concur_Core_Types.widgetApplicative)([  ]);
    };
    if (v instanceof Data_Either.Left) {
        return Control_Bind.bind(Concur_Core_Types.widgetBind)(v.value0)(function (r) {
            return Control_Bind.bind(Concur_Core_Types.widgetBind)(genToList(r.cont))(function (rs) {
                return Control_Applicative.pure(Concur_Core_Types.widgetApplicative)((function () {
                    if (r["yield"] instanceof Data_Maybe.Nothing) {
                        return rs;
                    };
                    if (r["yield"] instanceof Data_Maybe.Just) {
                        return Data_Array.snoc(rs)(r["yield"].value0);
                    };
                    throw new Error("Failed pattern match at Concur.Core.Gen (line 142, column 10 - line 144, column 26): " + [ r["yield"].constructor.name ]);
                })());
            });
        });
    };
    throw new Error("Failed pattern match at Concur.Core.Gen (line 137, column 15 - line 144, column 26): " + [ v.constructor.name ]);
};
var zipYield = (function () {
    var go = function (n) {
        return function (g) {
            var v = Control_Monad_Free.resume(functorGenStep)(g);
            if (v instanceof Data_Either.Right) {
                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(v.value0);
            };
            if (v instanceof Data_Either.Left) {
                return Control_Bind.bind(Control_Monad_Free.freeBind)(runWidget(v.value0))(function (r) {
                    if (r["yield"] instanceof Data_Maybe.Nothing) {
                        return go(n)(r.cont);
                    };
                    if (r["yield"] instanceof Data_Maybe.Just) {
                        return yieldAndThen(new Data_Tuple.Tuple(n, r["yield"].value0))(Control_Applicative.pure(Concur_Core_Types.widgetApplicative)(go(n + 1 | 0)(r.cont)));
                    };
                    throw new Error("Failed pattern match at Concur.Core.Gen (line 74, column 7 - line 76, column 70): " + [ r["yield"].constructor.name ]);
                });
            };
            throw new Error("Failed pattern match at Concur.Core.Gen (line 70, column 12 - line 76, column 70): " + [ v.constructor.name ]);
        };
    };
    return go(0);
})();
var zipWidgetYield = function (dictFunctor) {
    return function (g) {
        return mapYield(function (v) {
            return Data_Functor.map(dictFunctor)(Data_Tuple.Tuple.create(v.value0))(v.value1);
        })(zipYield(g));
    };
};
var zipGenOrr = function (dictMonoid) {
    var $39 = genOrr(dictMonoid);
    var $40 = zipWidgetYield(Concur_Core_Types.widgetFunctor);
    return function ($41) {
        return $39($40($41));
    };
};
module.exports = {
    GenStep: GenStep,
    "yield": $$yield,
    runWidget: runWidget,
    yieldAndThen: yieldAndThen,
    mapYield: mapYield,
    zipYield: zipYield,
    zipWidgetYield: zipWidgetYield,
    genOrr: genOrr,
    zipGenOrr: zipGenOrr,
    listToGen: listToGen,
    genToList: genToList,
    mapYieldGenWidget: mapYieldGenWidget,
    mapContGenWidget: mapContGenWidget,
    pureYield: pureYield,
    widgetYield: widgetYield,
    functorGenStep: functorGenStep
};

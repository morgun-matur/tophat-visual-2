// Generated by purs version 0.14.2
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Plus = require("../Control.Plus/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Bifoldable = require("../Data.Bifoldable/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Enum = require("../Data.Enum/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HashMap = require("../Data.HashMap/index.js");
var Data_HashSet = require("../Data.HashSet/index.js");
var Data_Hashable = require("../Data.Hashable/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_List = require("../Data.List/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_NonEmpty = require("../Data.NonEmpty/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Debug = require("../Debug/index.js");
var Effect = require("../Effect/index.js");
var Prelude = require("../Prelude/index.js");
var Safe_Coerce = require("../Safe.Coerce/index.js");
var Nat = function (x) {
    return x;
};
var Initialise = function (from) {
    this.from = from;
};
var Group = function (Monoid0, invert, subtract) {
    this.Monoid0 = Monoid0;
    this.invert = invert;
    this.subtract = subtract;
};
var Module = function (Group0, Semiring1, scale) {
    this.Group0 = Group0;
    this.Semiring1 = Semiring1;
    this.scale = scale;
};
var Torsor = function (Group0, adjust, diff) {
    this.Group0 = Group0;
    this.adjust = adjust;
    this.diff = diff;
};
var words = function (dictUnfoldable) {
    var $59 = Data_Array.toUnfoldable(dictUnfoldable);
    var $60 = Data_String_Common.split(" ");
    return function ($61) {
        return $59($60($61));
    };
};
var withDefault = Data_Function.flip(Data_Maybe.fromMaybe);
var using = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (dictFunctor) {
            return function (v) {
                return function (f) {
                    var $62 = Data_Newtype.unwrap();
                    var $63 = Data_Functor.map(dictFunctor)(Data_Newtype.wrap());
                    return function ($64) {
                        return $62(f($63($64)));
                    };
                };
            };
        };
    };
};
var unwords = function (dictFoldable) {
    return Data_Foldable.intercalate(dictFoldable)(Data_Monoid.monoidString)(" ");
};
var unnat = function (v) {
    return v;
};
var unlines = function (dictFoldable) {
    return Data_Foldable.intercalate(dictFoldable)(Data_Monoid.monoidString)("\x0a");
};
var trd = function (v) {
    return v.value1.value1;
};
var $$throw = Data_Either.Left.create;
var subtract = function (dict) {
    return dict.subtract;
};
var scale = function (dict) {
    return dict.scale;
};
var panic = function (s) {
    return Debug.spy()("PANIC: " + s)({});
};
var todo = function (dictWarn) {
    return panic;
};
var notMember = function (dictHashable) {
    return function (x) {
        var $65 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
        var $66 = Data_HashSet.member(dictHashable)(x);
        return function ($67) {
            return $65($66($67));
        };
    };
};
var neutral = function (dictMonoid) {
    return Data_Monoid.mempty(dictMonoid);
};
var nat = function (i) {
    if (i >= 0) {
        return i;
    };
    if (Data_Boolean.otherwise) {
        return 0;
    };
    throw new Error("Failed pattern match at Preload (line 299, column 1 - line 299, column 18): " + [ i.constructor.name ]);
};
var lines = function (dictUnfoldable) {
    var $68 = Data_Array.toUnfoldable(dictUnfoldable);
    var $69 = Data_String_Common.split("\x0a");
    return function ($70) {
        return $68($69($70));
    };
};
var invertDefault = function (dictGroup) {
    return function (x) {
        return subtract(dictGroup)(neutral(dictGroup.Monoid0()))(x);
    };
};
var invert = function (dict) {
    return dict.invert;
};
var subtractDefault = function (dictGroup) {
    return function (x) {
        return function (y) {
            return Data_Semigroup.append((dictGroup.Monoid0()).Semigroup0())(x)(invert(dictGroup)(y));
        };
    };
};
var indent = function (n) {
    return function (s) {
        return Data_Foldable.fold(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(Data_Unfoldable.replicate(Data_Unfoldable.unfoldableArray)(n)("  ")) + s;
    };
};
var gather = function (dictFoldable) {
    return function (dictMonad) {
        return Data_Foldable.foldM(dictFoldable)(dictMonad);
    };
};
var from = function (dict) {
    return dict.from;
};
var foldrInfix = function (dictFoldable) {
    return function (xs) {
        return function (x) {
            return function (f) {
                return Data_Foldable.foldr(dictFoldable)(f)(x)(xs);
            };
        };
    };
};
var foldr1 = function (dictFoldable) {
    return function (f) {
        return function (xs) {
            var mf = function (x) {
                return function (m) {
                    return Data_Maybe.Just.create((function () {
                        if (m instanceof Data_Maybe.Nothing) {
                            return x;
                        };
                        if (m instanceof Data_Maybe.Just) {
                            return f(x)(m.value0);
                        };
                        throw new Error("Failed pattern match at Preload (line 381, column 10 - line 383, column 33): " + [ m.constructor.name ]);
                    })());
                };
            };
            return Data_Foldable.foldr(dictFoldable)(mf)(Data_Maybe.Nothing.value)(xs);
        };
    };
};
var foldlInfix = function (dictFoldable) {
    return function (x) {
        return function (xs) {
            return function (f) {
                return Data_Foldable.foldl(dictFoldable)(f)(x)(xs);
            };
        };
    };
};
var enclose = function (a) {
    return function (b) {
        return function (s) {
            return Data_String_CodeUnits.singleton(a) + (s + Data_String_CodeUnits.singleton(b));
        };
    };
};
var quote = enclose("\"")("\"");
var done = function (dictApplicative) {
    return Control_Applicative.pure(dictApplicative);
};
var pair = function (dictApplicative) {
    return function (x) {
        return function (y) {
            return Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(done(dictApplicative)(Data_Tuple.Tuple.create))(x))(y);
        };
    };
};
var skip = function (dictApplicative) {
    return done(dictApplicative)(Data_Unit.unit);
};
var diff = function (dict) {
    return dict.diff;
};
var composeOr = function (f) {
    return function (g) {
        return function (x) {
            return f(x) || g(x);
        };
    };
};
var composeAnd = function (f) {
    return function (g) {
        return function (x) {
            return f(x) && g(x);
        };
    };
};
var adjust = function (dict) {
    return dict.adjust;
};
var $dollar_ShowNat_15 = new Data_Show.Show(function (v) {
    return "+" + Data_Show.show(Data_Show.showInt)(v);
});
var $dollar_SemiringNat_18 = new Data_Semiring.Semiring(function (v) {
    return function (v1) {
        return v + v1 | 0;
    };
}, function (v) {
    return function (v1) {
        return v * v1 | 0;
    };
}, 1, 0);
var $dollar_InitialiseList_12 = new Initialise(Data_List.fromFoldable(Data_Foldable.foldableArray));
var $dollar_InitialiseHashSet_13 = function (dictHashable) {
    return new Initialise(Data_HashSet.fromArray(dictHashable));
};
var $dollar_InitialiseHashMap$times_14 = function (dictHashable) {
    return new Initialise(Data_HashMap.fromArray(dictHashable));
};
var $dollar_EqNat_16 = new Data_Eq.Eq(function (v) {
    return function (v1) {
        return v === v1;
    };
});
var $dollar_OrdNat_17 = new Data_Ord.Ord(function () {
    return $dollar_EqNat_16;
}, function (v) {
    return function (v1) {
        return Data_Ord.compare(Data_Ord.ordInt)(v)(v1);
    };
});
module.exports = {
    composeAnd: composeAnd,
    composeOr: composeOr,
    trd: trd,
    "throw": $$throw,
    withDefault: withDefault,
    enclose: enclose,
    quote: quote,
    indent: indent,
    Initialise: Initialise,
    from: from,
    todo: todo,
    panic: panic,
    nat: nat,
    unnat: unnat,
    notMember: notMember,
    neutral: neutral,
    Group: Group,
    invert: invert,
    invertDefault: invertDefault,
    subtract: subtract,
    subtractDefault: subtractDefault,
    Module: Module,
    scale: scale,
    Torsor: Torsor,
    diff: diff,
    adjust: adjust,
    foldlInfix: foldlInfix,
    foldrInfix: foldrInfix,
    foldr1: foldr1,
    gather: gather,
    words: words,
    lines: lines,
    unwords: unwords,
    unlines: unlines,
    done: done,
    skip: skip,
    pair: pair,
    using: using,
    "$_InitialiseList_12": $dollar_InitialiseList_12,
    "$_InitialiseHashSet_13": $dollar_InitialiseHashSet_13,
    "$_InitialiseHashMap*_14": $dollar_InitialiseHashMap$times_14,
    "$_ShowNat_15": $dollar_ShowNat_15,
    "$_EqNat_16": $dollar_EqNat_16,
    "$_OrdNat_17": $dollar_OrdNat_17,
    "$_SemiringNat_18": $dollar_SemiringNat_18,
    Alt: Control_Alt.Alt,
    Alternative: Control_Alternative.Alternative,
    applyFirst: Control_Apply.applyFirst,
    applySecond: Control_Apply.applySecond,
    bindFlipped: Control_Bind.bindFlipped,
    Plus: Control_Plus.Plus,
    empty: Control_Plus.empty,
    Bifoldable: Data_Bifoldable.Bifoldable,
    biall: Data_Bifoldable.biall,
    biany: Data_Bifoldable.biany,
    bifold: Data_Bifoldable.bifold,
    bifoldMap: Data_Bifoldable.bifoldMap,
    bifoldMapDefaultL: Data_Bifoldable.bifoldMapDefaultL,
    bifoldMapDefaultR: Data_Bifoldable.bifoldMapDefaultR,
    bifoldl: Data_Bifoldable.bifoldl,
    bifoldlDefault: Data_Bifoldable.bifoldlDefault,
    bifoldr: Data_Bifoldable.bifoldr,
    bifoldrDefault: Data_Bifoldable.bifoldrDefault,
    bifor_: Data_Bifoldable.bifor_,
    bisequence_: Data_Bifoldable.bisequence_,
    bitraverse_: Data_Bifoldable.bitraverse_,
    Bifunctor: Data_Bifunctor.Bifunctor,
    bimap: Data_Bifunctor.bimap,
    lmap: Data_Bifunctor.lmap,
    rmap: Data_Bifunctor.rmap,
    Left: Data_Either.Left,
    Right: Data_Either.Right,
    choose: Data_Either.choose,
    either: Data_Either.either,
    fromLeft: Data_Either.fromLeft,
    "fromLeft'": Data_Either["fromLeft'"],
    fromRight: Data_Either.fromRight,
    "fromRight'": Data_Either["fromRight'"],
    hush: Data_Either.hush,
    isLeft: Data_Either.isLeft,
    isRight: Data_Either.isRight,
    note: Data_Either.note,
    "note'": Data_Either["note'"],
    Enum: Data_Enum.Enum,
    findMap: Data_Foldable.findMap,
    indexl: Data_Foldable.indexl,
    indexr: Data_Foldable.indexr,
    length: Data_Foldable.length,
    lookup: Data_Foldable.lookup,
    "null": Data_Foldable["null"],
    oneOfMap: Data_Foldable.oneOfMap,
    product: Data_Foldable.product,
    surround: Data_Foldable.surround,
    surroundMap: Data_Foldable.surroundMap,
    FoldableWithIndex: Data_FoldableWithIndex.FoldableWithIndex,
    allWithIndex: Data_FoldableWithIndex.allWithIndex,
    anyWithIndex: Data_FoldableWithIndex.anyWithIndex,
    findMapWithIndex: Data_FoldableWithIndex.findMapWithIndex,
    findWithIndex: Data_FoldableWithIndex.findWithIndex,
    foldMapWithIndex: Data_FoldableWithIndex.foldMapWithIndex,
    foldMapWithIndexDefaultL: Data_FoldableWithIndex.foldMapWithIndexDefaultL,
    foldMapWithIndexDefaultR: Data_FoldableWithIndex.foldMapWithIndexDefaultR,
    foldWithIndexM: Data_FoldableWithIndex.foldWithIndexM,
    foldlWithIndex: Data_FoldableWithIndex.foldlWithIndex,
    foldlWithIndexDefault: Data_FoldableWithIndex.foldlWithIndexDefault,
    foldrWithIndex: Data_FoldableWithIndex.foldrWithIndex,
    foldrWithIndexDefault: Data_FoldableWithIndex.foldrWithIndexDefault,
    forWithIndex_: Data_FoldableWithIndex.forWithIndex_,
    surroundMapWithIndex: Data_FoldableWithIndex.surroundMapWithIndex,
    traverseWithIndex_: Data_FoldableWithIndex.traverseWithIndex_,
    on: Data_Function.on,
    mapFlipped: Data_Functor.mapFlipped,
    voidLeft: Data_Functor.voidLeft,
    voidRight: Data_Functor.voidRight,
    Hashable: Data_Hashable.Hashable,
    Just: Data_Maybe.Just,
    Nothing: Data_Maybe.Nothing,
    fromJust: Data_Maybe.fromJust,
    "fromMaybe'": Data_Maybe["fromMaybe'"],
    isJust: Data_Maybe.isJust,
    isNothing: Data_Maybe.isNothing,
    maybe: Data_Maybe.maybe,
    "maybe'": Data_Maybe["maybe'"],
    optional: Data_Maybe.optional,
    Newtype: Data_Newtype.Newtype,
    ala: Data_Newtype.ala,
    over: Data_Newtype.over,
    over2: Data_Newtype.over2,
    under: Data_Newtype.under,
    under2: Data_Newtype.under2,
    unwrap: Data_Newtype.unwrap,
    wrap: Data_Newtype.wrap,
    NonEmpty: Data_NonEmpty.NonEmpty,
    Foldable: Data_Traversable.Foldable,
    Traversable: Data_Traversable.Traversable,
    all: Data_Traversable.all,
    and: Data_Traversable.and,
    any: Data_Traversable.any,
    elem: Data_Traversable.elem,
    find: Data_Traversable.find,
    fold: Data_Traversable.fold,
    foldMap: Data_Traversable.foldMap,
    foldMapDefaultL: Data_Traversable.foldMapDefaultL,
    foldMapDefaultR: Data_Traversable.foldMapDefaultR,
    foldl: Data_Traversable.foldl,
    foldlDefault: Data_Traversable.foldlDefault,
    foldr: Data_Traversable.foldr,
    foldrDefault: Data_Traversable.foldrDefault,
    "for": Data_Traversable["for"],
    for_: Data_Traversable.for_,
    intercalate: Data_Traversable.intercalate,
    mapAccumL: Data_Traversable.mapAccumL,
    mapAccumR: Data_Traversable.mapAccumR,
    maximum: Data_Traversable.maximum,
    maximumBy: Data_Traversable.maximumBy,
    minimum: Data_Traversable.minimum,
    minimumBy: Data_Traversable.minimumBy,
    notElem: Data_Traversable.notElem,
    oneOf: Data_Traversable.oneOf,
    or: Data_Traversable.or,
    scanl: Data_Traversable.scanl,
    scanr: Data_Traversable.scanr,
    sequence: Data_Traversable.sequence,
    sequenceDefault: Data_Traversable.sequenceDefault,
    sequence_: Data_Traversable.sequence_,
    sum: Data_Traversable.sum,
    traverse: Data_Traversable.traverse,
    traverseDefault: Data_Traversable.traverseDefault,
    traverse_: Data_Traversable.traverse_,
    curry: Data_Tuple.curry,
    fst: Data_Tuple.fst,
    snd: Data_Tuple.snd,
    swap: Data_Tuple.swap,
    uncurry: Data_Tuple.uncurry,
    Unfoldable: Data_Unfoldable.Unfoldable,
    Unfoldable1: Data_Unfoldable.Unfoldable1,
    fromMaybe: Data_Unfoldable.fromMaybe,
    none: Data_Unfoldable.none,
    range: Data_Unfoldable.range,
    replicate: Data_Unfoldable.replicate,
    replicate1: Data_Unfoldable.replicate1,
    replicate1A: Data_Unfoldable.replicate1A,
    replicateA: Data_Unfoldable.replicateA,
    singleton: Data_Unfoldable.singleton,
    unfoldr: Data_Unfoldable.unfoldr,
    unfoldr1: Data_Unfoldable.unfoldr1,
    spy: Debug.spy,
    EQ: Prelude.EQ,
    GT: Prelude.GT,
    LT: Prelude.LT,
    Applicative: Prelude.Applicative,
    Apply: Prelude.Apply,
    Bind: Prelude.Bind,
    BooleanAlgebra: Prelude.BooleanAlgebra,
    Bounded: Prelude.Bounded,
    Category: Prelude.Category,
    CommutativeRing: Prelude.CommutativeRing,
    Discard: Prelude.Discard,
    DivisionRing: Prelude.DivisionRing,
    Eq: Prelude.Eq,
    EuclideanRing: Prelude.EuclideanRing,
    Field: Prelude.Field,
    Functor: Prelude.Functor,
    HeytingAlgebra: Prelude.HeytingAlgebra,
    Monad: Prelude.Monad,
    Monoid: Prelude.Monoid,
    Ord: Prelude.Ord,
    Ring: Prelude.Ring,
    Semigroup: Prelude.Semigroup,
    Semigroupoid: Prelude.Semigroupoid,
    Semiring: Prelude.Semiring,
    Show: Prelude.Show,
    absurd: Prelude.absurd,
    add: Prelude.add,
    ap: Prelude.ap,
    append: Prelude.append,
    apply: Prelude.apply,
    between: Prelude.between,
    bind: Prelude.bind,
    bottom: Prelude.bottom,
    clamp: Prelude.clamp,
    compare: Prelude.compare,
    comparing: Prelude.comparing,
    compose: Prelude.compose,
    conj: Prelude.conj,
    "const": Prelude["const"],
    degree: Prelude.degree,
    discard: Prelude.discard,
    disj: Prelude.disj,
    div: Prelude.div,
    eq: Prelude.eq,
    flap: Prelude.flap,
    flip: Prelude.flip,
    gcd: Prelude.gcd,
    identity: Prelude.identity,
    ifM: Prelude.ifM,
    join: Prelude.join,
    lcm: Prelude.lcm,
    liftA1: Prelude.liftA1,
    liftM1: Prelude.liftM1,
    map: Prelude.map,
    max: Prelude.max,
    min: Prelude.min,
    mod: Prelude.mod,
    mul: Prelude.mul,
    negate: Prelude.negate,
    not: Prelude.not,
    notEq: Prelude.notEq,
    one: Prelude.one,
    otherwise: Prelude.otherwise,
    recip: Prelude.recip,
    show: Prelude.show,
    sub: Prelude.sub,
    top: Prelude.top,
    unit: Prelude.unit,
    unless: Prelude.unless,
    unlessM: Prelude.unlessM,
    "void": Prelude["void"],
    when: Prelude.when,
    whenM: Prelude.whenM,
    zero: Prelude.zero,
    coerce: Safe_Coerce.coerce
};
